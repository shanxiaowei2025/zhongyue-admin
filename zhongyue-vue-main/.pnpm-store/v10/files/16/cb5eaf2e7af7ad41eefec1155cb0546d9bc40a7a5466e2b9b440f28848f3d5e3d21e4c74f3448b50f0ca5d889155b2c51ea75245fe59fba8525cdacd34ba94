import GraphModel from './GraphModel';
import { BaseNodeModel } from './node';
import LogicFlow from '../LogicFlow';
import { ElementState } from '../constant';
export declare namespace Model {
    import PropertiesType = LogicFlow.PropertiesType;
    type AdditionStateDataType = Record<string, unknown>;
    type PropertyType = Record<string, unknown>;
    type VectorType = [number, number];
    type IsAllowMove = {
        x: boolean;
        y: boolean;
    };
    type AnchorConfig = {
        id?: string;
        x: number;
        y: number;
        [key: string]: unknown;
    };
    type AnchorInfo = {
        index: number;
        anchor: AnchorConfig;
    };
    type ConnectRule = {
        message: string;
        validate: (source?: BaseNodeModel, target?: BaseNodeModel, sourceAnchor?: AnchorConfig, targetAnchor?: AnchorConfig, 
        /**
         * REMIND: è°ƒæ•´çš„è¾¹çš„ id
         * åœ¨å¼€å¯ adjustEdgeStartAndEnd åŽè°ƒæ•´è¾¹è¿žæŽ¥çš„èŠ‚ç‚¹æ—¶ä¼šä¼ å…¥
         * è¯¦è§ï¼šhttps://github.com/didi/LogicFlow/issues/926#issuecomment-1371823306
         */
        edgeID?: string) => boolean | undefined;
    };
    type ConnectRuleResult = {
        isAllPass: boolean;
        msg?: string;
    };
    /**
     * é™åˆ¶èŠ‚ç‚¹ç§»åŠ¨è§„åˆ™
     * model: ç§»åŠ¨èŠ‚ç‚¹çš„ model
     * deltaX: ç§»åŠ¨çš„ X è½´è·ç¦»
     * deltaY: ç§»åŠ¨çš„ Y è½´è·ç¦»
     */
    type NodeMoveRule = (model: BaseNodeModel, deltaX: number, deltaY: number) => boolean | IsAllowMove;
    type AdjustEdgeStartAndEndParams = {
        startPoint: LogicFlow.Point;
        endPoint: LogicFlow.Point;
        sourceNode?: BaseNodeModel;
        targetNode?: BaseNodeModel;
    };
    type BoxBoundsPoint = {
        minX: number;
        minY: number;
        maxX: number;
        maxY: number;
    };
    interface BoxBounds extends BoxBoundsPoint {
        x: number;
        y: number;
        width: number;
        height: number;
        centerX: number;
        centerY: number;
    }
    type OutlineInfo = {
        x: number;
        y: number;
        x1: number;
        y1: number;
    };
    interface BoxBounds {
        x: number;
        y: number;
        width: number;
        height: number;
        minX: number;
        minY: number;
        maxX: number;
        maxY: number;
        centerX: number;
        centerY: number;
    }
    interface BaseModel<P extends PropertiesType = PropertiesType> {
        /**
         * èŠ‚ç‚¹æˆ–è¾¹å¯¹åº”çš„ ID.
         *
         * é»˜è®¤æƒ…å†µä¸‹ï¼Œä½¿ç”¨ uuidV4 ç”Ÿæˆã€‚å¦‚éœ€è‡ªå®šä¹‰ï¼Œå¯é€šè¿‡ä¼ å…¥ createId æ–¹æ³•è¦†ç›–ã€‚
         */
        id: string;
        /**
         * model å¯¹åº”çš„å›¾å½¢å¤–è§‚ç±»åž‹ (eg: åœ†å½¢ã€çŸ©å½¢ã€å¤šè¾¹å½¢ç­‰)
         *
         * ä¸å¯è‡ªå®šä¹‰ï¼Œç”¨äºŽ LogicFlow å†…éƒ¨è®¡ç®—ä½¿ç”¨
         */
        readonly modelType: string;
        /**
         * è¯·å‹¿ç›´æŽ¥ä¿®æ”¹å±žæ€§ï¼Œå¦‚æžœæƒ³è¦å°†ä¸€ä¸ªèŠ‚ç‚¹ç±»åž‹ä¿®æ”¹ä¸ºå¦ä¸€ä¸ªç±»åž‹ã€‚ï¼ˆç›´æŽ¥ç¦æ­¢ä¿®æ”¹ä¸å°±å¯ä»¥äº† public readonlyï¼‰
         * `lf.graphModel.changeEdgeType` or `lf.graphModel.changeNodeType`
         *
         * æµç¨‹å›¾å…ƒç´ ç±»åž‹ï¼Œè‡ªå®šä¹‰å…ƒç´ æ—¶å¯¹åº”çš„æ ‡è¯†
         * åœ¨ logicflow/core ä¸­å¯¹åº”ç€ rect/circle/polyline è¿™ç§
         * åœ¨å®žé™…é¡¹ç›®ä¸­ï¼Œæˆ‘ä»¬ä¼šåŸºäºŽä¸šåŠ¡ç±»åž‹è¿›è¡Œè‡ªå®šä¹‰ type.
         * ä¾‹å¦‚ BPMN åœºæ™¯ä¸­ï¼Œæˆ‘ä»¬ä¼šå®šä¹‰å¼€å§‹èŠ‚ç‚¹çš„ç±»åž‹ä¸º bpmn:start-event
         *
         * ä¸Ž modelType çš„åŒºåˆ«æ˜¯ï¼Œtype æ›´å¤šçš„æ˜¯ä¸šåŠ¡ä¸Šçš„ç±»åž‹ï¼Œè€Œ modelType åˆ™æ˜¯å¤–è§‚ä¸Šçš„ç±»åž‹ã€‚
         * ä¾‹å¦‚ bpmn.js çš„å¼€å§‹èŠ‚ç‚¹å’Œç»“æŸèŠ‚ç‚¹ type åˆ†åˆ«ä¸º 'bpmn:start-event' å’Œ 'bpmn:end-event'ã€‚
         * ä½†æ˜¯ä»–ä»¬çš„ modelType éƒ½æ˜¯ circle-nodeï¼Œå› ä¸ºä»–ä»¬çš„å¤–è§‚éƒ½æ˜¯åŸºäºŽåœ†å½¢è‡ªå®šä¹‰è€Œæ¥ã€‚
         */
        readonly type: string;
        graphModel: GraphModel;
        /**
         * çŠ¶æ€é™„åŠ æ•°æ®ï¼Œä¾‹å¦‚æ˜¾ç¤ºèœå•ï¼Œèœå•çš„ä½ç½®ä¿¡æ¯
         * @deprecated: è¯·å‹¿ä½¿ç”¨ï¼Œå³å°†åºŸå¼ƒ
         */
        additionStateData?: AdditionStateDataType;
        /**
         * Rule ç›¸å…³é…ç½®ï¼ŒåŒ…æ‹¬è¿žå…¥ã€è¿žå‡ºã€ç§»åŠ¨ç­‰
         */
        targetRules?: ConnectRule[];
        sourceRules?: ConnectRule[];
        moveRules?: NodeMoveRule[];
        hasSetTargetRules?: boolean;
        hasSetSourceRules?: boolean;
        /**
         * å…ƒç´ ä¸Šçš„æ–‡æœ¬
         *
         * LogicFlow ä¸­å­˜åœ¨ä¸¤ç§æ–‡æœ¬ï¼š1. è„±ç¦»è¾¹å’ŒèŠ‚ç‚¹å•ç‹¬å­˜åœ¨çš„é—®é¢˜ï¼›2. å¿…é¡»å’Œè¾¹ã€èŠ‚ç‚¹å…³è”çš„æ–‡æœ¬
         * æ­¤å±žæ€§æŽ§åˆ¶çš„æ˜¯ç¬¬äºŒç§ã€‚èŠ‚ç‚¹å’Œè¾¹åœ¨åˆ é™¤ã€è°ƒæ•´çš„åŒæ—¶ï¼Œå…¶å…³è”çš„æ–‡æœ¬ä¹Ÿä¼šå¯¹åº”åˆ é™¤ã€è°ƒæ•´ã€‚
         */
        text: LogicFlow.TextConfig;
        properties: P;
        isSelected: boolean;
        isHovered: boolean;
        isHitable: boolean;
        isHittable: boolean;
        draggable: boolean;
        visible: boolean;
        virtual: boolean;
        /**
         * å…ƒç´ å †å çš„å±‚çº§ï¼Œé»˜è®¤æƒ…å†µä¸‹èŠ‚ç‚¹ zIndex å€¼ä¸º 1ï¼Œè¾¹ zIndex ä¸º 0
         */
        zIndex: number;
        /**
         * å…ƒç´ çŠ¶æ€: ä¸åŒçŠ¶æ€ä¸åº”ä¸åŒå…ƒç´ çš„æ˜¾ç¤ºæ•ˆæžœï¼ˆæ— æ³•ç›´æŽ¥ä¿®æ”¹ï¼‰
         */
        readonly state: ElementState;
        /**
         * åˆ›å»ºèŠ‚ç‚¹ ID
         *
         * é»˜è®¤æƒ…å†µä¸‹ï¼ŒLogicFlow å†…éƒ¨ä½¿ç”¨ uuidV4 ç”Ÿæˆ idã€‚åœ¨è‡ªå®šä¹‰èŠ‚ç‚¹çš„æ—¶å€™ï¼Œå¯ä»¥é‡å†™æ­¤æ–¹æ³•ï¼Œ
         * åŸºäºŽè‡ªå·±çš„è§„åˆ™ç”Ÿæˆ idã€‚
         * æ³¨æ„ ðŸ“¢ï¼šæ­¤æ–¹æ³•å¿…é¡»æ˜¯åŒæ­¥æ–¹æ³•ï¼Œå¦‚æžœæƒ³è¦å¼‚æ­¥ä¿®æ”¹ IDï¼Œå»ºè®®åˆ é™¤æ­¤èŠ‚ç‚¹åŽåœ¨åŒä¸€ä½ç½®åˆ›å»ºä¸€ä¸ªæ–°çš„èŠ‚ç‚¹
         * @overridable å¯è¢«é‡å†™
         * @returns string
         */
        createId: () => string | null;
        isAllowMoveNode?: (deltaX: number, deltaY: number) => boolean | IsAllowMove;
        moveText: (deltaX: number, deltaY: number) => void;
        moveTo?: (x: number, y: number, isIgnoreRule: boolean) => boolean;
        getMoveDistance?: (deltaX: number, deltaY: number, isIgnoreRule: boolean) => VectorType;
        move?: (x: number, y: number, isIgnoreRule: boolean) => boolean;
        updateText: (text: string) => void;
        setSelected: (isSelected: boolean) => void;
        setHovered: (isHovered: boolean) => void;
        setHitable: (isHittable: boolean) => void;
        setHittable: (isHittable: boolean) => void;
        setZIndex: (zIndex?: number) => void;
        updateAttributes: (attributes: LogicFlow.AttributesType) => void;
        /**
         * è®¾ç½® Node | Edge ç­‰ model çš„çŠ¶æ€
         * @param state çŠ¶æ€
         * @param additionStateData é¢å¤–çš„å‚æ•°
         */
        setElementState: (state: ElementState, additionStateData?: AdditionStateDataType) => void;
        getData: () => Record<string, unknown>;
        getProperties: () => PropertyType;
        setProperty: (key: string, val: unknown) => void;
        setProperties: (properties: PropertyType) => void;
        deleteProperty: (key: string) => void;
        getNodeStyle?: () => LogicFlow.CommonTheme;
        getEdgeStyle?: () => LogicFlow.EdgeTheme;
        getTextStyle: () => LogicFlow.TextNodeTheme;
        getAnchorStyle?: () => LogicFlow.AnchorTheme;
        getAnchorLineStyle?: () => LogicFlow.AnchorLineTheme;
        getOutlineStyle: () => LogicFlow.OutlineTheme;
        setStyle: (key: string, val: LogicFlow.CommonThemePropTypes) => void;
        setStyles: (styles: LogicFlow.CommonTheme) => void;
        updateStyles: (styles: LogicFlow.CommonTheme) => void;
    }
}
