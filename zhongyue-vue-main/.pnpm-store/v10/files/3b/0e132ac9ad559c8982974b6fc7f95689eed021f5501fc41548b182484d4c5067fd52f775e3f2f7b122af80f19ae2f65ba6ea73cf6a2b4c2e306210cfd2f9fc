/**
 * Name: vite-plugin-fake-server
 * Version: 2.1.1
 * Author: Condor Hero
 * Homepage: https://github.com/condorheroblog/vite-plugin-fake-server/blob/main/README.md
 * License MIT Â© 2023-Present
 */

'use strict';

var node_fs = require('node:fs');
var node_module = require('node:module');
var node_path = require('node:path');
var node_http = require('node:http');
var promises = require('node:fs/promises');
var colors = require('picocolors');
var fg = require('fast-glob');
var node_url = require('node:url');
var pathToRegexp = require('path-to-regexp');
var EventEmitter = require('node:events');
var bundleImport = require('bundle-import');
var chokidar = require('chokidar');
var node_os = require('node:os');
var readline = require('node:readline');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
var name = "vite-plugin-fake-server";
var version = "2.1.1";
var type = "module";
var license = "MIT";
var author = "Condor Hero";
var description = "A fake server plugin for Vite.";
var exports$1 = {
	".": {
		require: "./dist/index.cjs",
		"import": "./dist/index.mjs"
	},
	"./client": {
		require: "./dist/client.cjs",
		"import": "./dist/client.mjs"
	}
};
var main = "dist/index.cjs";
var module$1 = "dist/index.mjs";
var types = "dist/index.d.cts";
var typesVersions = {
	"*": {
		"*": [
			"./dist/*",
			"./dist/index.d.ts"
		]
	}
};
var files = [
	"dist"
];
var keywords = [
	"vite-plugin-fake-server",
	"vite-plugin-fake",
	"vite-plugin-faker",
	"vite-plugin-mock-server",
	"vite-plugin-mock",
	"faker-server"
];
var repository = {
	type: "git",
	url: "git+https://github.com/condorheroblog/vite-plugin-fake-server.git",
	directory: "packages/vite-plugin-fake-server"
};
var bugs = {
	url: "https://github.com/condorheroblog/vite-plugin-fake-server/issues"
};
var homepage = "https://github.com/condorheroblog/vite-plugin-fake-server/blob/main/README.md";
var scripts = {
	prepublishOnly: "nr build",
	test: "vitest",
	dev: "esno ./src/index.ts",
	build: "rimraf dist && rollup -c",
	"build:watch": "rimraf dist && rollup -c -w",
	typecheck: "tsc --noEmit"
};
var dependencies = {
	"bundle-import": "^0.0.1",
	chokidar: "^3.5.3",
	"fast-glob": "^3.3.2",
	"path-to-regexp": "^6.2.1",
	picocolors: "^1.0.0"
};
var devDependencies = {
	vite: "^5.0.11"
};
var publishConfig = {
	access: "public",
	registry: "https://registry.npmjs.org"
};
var pkg = {
	name: name,
	version: version,
	type: type,
	license: license,
	author: author,
	description: description,
	exports: exports$1,
	main: main,
	module: module$1,
	types: types,
	typesVersions: typesVersions,
	files: files,
	keywords: keywords,
	repository: repository,
	bugs: bugs,
	homepage: homepage,
	scripts: scripts,
	dependencies: dependencies,
	devDependencies: devDependencies,
	publishConfig: publishConfig
};

const FAKE_FILE_EXTENSIONS = ["ts", "js", "mjs", "cjs", "cts", "mts"];
const INFIX_NAME = "fake";

function resolveOptions(options = {}) {
  const include = options.include ?? [INFIX_NAME];
  if (!Array.isArray(include) || include.length === 0) {
    throw new Error("Invalid include option");
  }
  let infixName;
  if (typeof options.infixName === "boolean") {
    if (options.infixName) {
      infixName = INFIX_NAME;
    } else {
      infixName = false;
    }
  } else if (typeof options.infixName === "string") {
    if (options.infixName.length === 0) {
      infixName = false;
    } else {
      infixName = options.infixName;
    }
  } else {
    infixName = INFIX_NAME;
  }
  return {
    include,
    exclude: options.exclude || [],
    infixName,
    extensions: options.extensions || FAKE_FILE_EXTENSIONS
  };
}

function isFunction(fn) {
  return typeof fn === "function";
}

const LogLevels = {
  silent: 0,
  error: 1,
  warn: 2,
  info: 3
};
let lastType;
let lastMsg;
let sameCount = 0;
function clearScreen() {
  const repeatCount = process.stdout.rows - 2;
  const blank = repeatCount > 0 ? "\n".repeat(repeatCount) : "";
  console.log(blank);
  readline.cursorTo(process.stdout, 0, 0);
  readline.clearScreenDown(process.stdout);
}
function createLogger(level = "info", options = {}) {
  if (options.customLogger) {
    return options.customLogger;
  }
  const timeFormatter = new Intl.DateTimeFormat(void 0, {
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  });
  const loggedErrors = /* @__PURE__ */ new WeakSet();
  const { prefix = `[${name}]`, allowClearScreen = true } = options;
  const thresh = LogLevels[level];
  const canClearScreen = allowClearScreen && process.stdout.isTTY && !process.env.CI;
  const clear = canClearScreen ? clearScreen : () => {
  };
  function output(type, msg, options2 = {}) {
    if (thresh >= LogLevels[type]) {
      const method = type === "info" ? "log" : type;
      const format = () => {
        if (options2.timestamp) {
          const tag = type === "info" ? colors.cyan(colors.bold(prefix)) : type === "warn" ? colors.yellow(colors.bold(prefix)) : colors.red(colors.bold(prefix));
          return `${colors.dim(timeFormatter.format(/* @__PURE__ */ new Date()))} ${tag} ${msg}`;
        } else {
          return msg;
        }
      };
      if (options2.error) {
        loggedErrors.add(options2.error);
      }
      if (canClearScreen) {
        if (type === lastType && msg === lastMsg) {
          sameCount++;
          clear();
          console[method](format(), colors.yellow(`(x${sameCount + 1})`));
        } else {
          sameCount = 0;
          lastMsg = msg;
          lastType = type;
          if (options2.clear) {
            clear();
          }
          console[method](format());
        }
      } else {
        console[method](format());
      }
    }
  }
  const warnedMessages = /* @__PURE__ */ new Set();
  const logger = {
    hasWarned: false,
    info(msg, opts) {
      output("info", msg, opts);
    },
    warn(msg, opts) {
      logger.hasWarned = true;
      output("warn", msg, opts);
    },
    warnOnce(msg, opts) {
      if (warnedMessages.has(msg))
        return;
      logger.hasWarned = true;
      output("warn", msg, opts);
      warnedMessages.add(msg);
    },
    error(msg, opts) {
      logger.hasWarned = true;
      output("error", msg, opts);
    },
    clearScreen(type) {
      if (thresh >= LogLevels[type]) {
        clear();
      }
    },
    hasErrorLogged(error) {
      return loggedErrors.has(error);
    }
  };
  return logger;
}

function getRequestData(req) {
  return new Promise((resolve, reject) => {
    let body = "";
    req.on("data", (chunk) => {
      body += chunk.toString();
    });
    req.on("end", () => {
      resolve(body);
    });
    req.on("error", (error) => {
      reject(error);
    });
  });
}

const DOS_DEVICE_PATH_RE = /^\\\\(?<path>[.?])/;
const WINDOWS_BACKSLASHES_RE = /\\(?![!()+@{}])/g;
function convertPathToPosix(path) {
  return node_os.platform() === "win32" ? path.replace(DOS_DEVICE_PATH_RE, "//$1").replaceAll(WINDOWS_BACKSLASHES_RE, "/") : path;
}

function getFakeFilePath(options, cwd = process.cwd()) {
  const { include, exclude, extensions, infixName } = options;
  if (!Array.isArray(include) || include.length === 0) {
    return [];
  }
  const fastGlobIgnore = exclude.map((filepath) => convertPathToPosix(node_path.join(cwd, filepath)));
  const posixStyleCurrentWorkingDirectory = convertPathToPosix(cwd);
  const fastGlobOptions = {
    posixStyleCurrentWorkingDirectory,
    ignore: fastGlobIgnore
  };
  const fakeFilePath = include.reduce((acc, filePath) => {
    const absFilePath = node_path.join(cwd, filePath);
    if (node_fs.existsSync(absFilePath)) {
      const fileExtname = node_path.extname(absFilePath).slice(1);
      const fileStatus = node_fs.statSync(absFilePath);
      if (!fileStatus.isDirectory() && fileExtname) {
        if (extensions.includes(fileExtname)) {
          const fakeFiles = fg.sync(convertPathToPosix(absFilePath), fastGlobOptions);
          return [...acc, ...fakeFiles];
        }
        return acc;
      }
      const dir = node_path.join(absFilePath, "/");
      const fakeFolderFiles = fg.sync(
        extensions.map((ext) => {
          if (infixName && infixName.length > 0) {
            return convertPathToPosix(`${dir}**/*.${infixName}.${ext}`);
          }
          return convertPathToPosix(`${dir}**/*.${ext}`);
        }),
        fastGlobOptions
      );
      return [...acc, ...fakeFolderFiles];
    }
    return acc;
  }, []);
  return fakeFilePath;
}

function parallelLoader(promises, limit = Infinity) {
  const len = promises.length;
  if (len === 0) {
    return Promise.resolve([]);
  }
  let current = 0;
  const result = [];
  let resolvedCount = 0;
  return new Promise((resolve, reject) => {
    function processNext() {
      const index = current;
      current = index + 1;
      const promise = promises[index];
      Promise.resolve(promise()).then((res) => {
        if (Array.isArray(res)) {
          result.push(...res);
        } else {
          result.push(res);
        }
        resolvedCount = resolvedCount + 1;
        if (resolvedCount === len) {
          resolve(result);
        }
        if (current < len)
          processNext();
      }).catch((reason) => reject(reason));
    }
    for (let i = 0; i < limit && i < len; i++) {
      processNext();
    }
  });
}

const PORT = 8888;
const OUTPUT_DIR = "fakeServer";
async function generateFakeServer(options, config) {
  const buildOptions = options.build === true ? { port: PORT, outDir: OUTPUT_DIR } : options.build;
  const { port = PORT, outDir = OUTPUT_DIR } = buildOptions;
  const cwd = process.cwd();
  const outputDir = node_path.join(cwd, outDir);
  const outputList = [
    {
      filename: node_path.join(outputDir, "index.js"),
      source: generatorServerEntryCode(port, options, config)
    },
    {
      filename: node_path.join(outputDir, "package.json"),
      source: generatePackageJson()
    }
  ];
  if (!node_fs.existsSync(outputDir)) {
    await promises.mkdir(outputDir, { recursive: true });
  }
  await copyFakeFiles(node_path.join(cwd, options.include), node_path.join(outputDir, options.include));
  for (const { filename, source } of outputList) {
    await promises.writeFile(filename, source, "utf-8");
  }
  console.log(`
[${name}]Builded a independently service in`, colors.green(outputDir), "\n");
  console.log(colors.yellow(`
This is just a template, you can adjust it according to your needs
`));
  console.log(
    `We suggest that you begin by typing:

  ${colors.blue("cd")} ${outDir}
  ${colors.blue("npm install")}
  ${colors.blue(
      "npm run start"
    )}

Happy Hacking!
See more: ${colors.underline(
      colors.blue("https://github.com/condorheroblog/vite-plugin-fake-server#build")
    )}`
  );
}
function generatePackageJson() {
  const fakePkg = {
    name: "fake-server",
    version,
    private: true,
    type: "module",
    scripts: {
      start: "node index.js"
    },
    dependencies: {
      connect: "latest",
      [name]: `^${version}`
    }
  };
  return JSON.stringify(fakePkg, null, 2);
}
function generatorServerEntryCode(port, options, config) {
  return `import connect from "connect";
import { createFakeMiddleware, createLogger } from "${name}";

const loggerOutput = createLogger(${JSON.stringify(config.logLevel)}, {
	allowClearScreen: ${config.clearScreen},
	// customLogger: ${config.customLogger},
});

async function main() {

	const app = connect();
	const middleware = await createFakeMiddleware(
		{
			...${JSON.stringify(options, null, 2)},
			loggerOutput,
			// config.root
			root: process.cwd(),
		},
		app
	);
	app.use(middleware);

	app.listen(${port});
	console.log("listen: http://localhost:${port}");
}

main();
`;
}
async function copyFakeFiles(sourceDir, targetDir) {
  try {
    if (!node_fs.existsSync(targetDir)) {
      await promises.mkdir(targetDir, { recursive: true });
    }
    const files = await promises.readdir(sourceDir);
    for (const file of files) {
      const sourcePath = node_path.join(sourceDir, file);
      const targetPath = node_path.join(targetDir, file);
      const fileStatus = await promises.stat(sourcePath);
      if (fileStatus.isDirectory()) {
        await copyFakeFiles(sourcePath, targetPath);
      } else {
        const ext = node_path.extname(file).toLowerCase().slice(1);
        if (FAKE_FILE_EXTENSIONS.includes(ext)) {
          await promises.copyFile(sourcePath, targetPath);
        }
      }
    }
  } catch (error) {
    console.error(`Error copying fake files: ${error}`);
  }
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _moduleCache, _fakeFileDeps, _fakeData;
class FakeFileLoader extends EventEmitter {
  constructor(options) {
    super();
    this.options = options;
    __privateAdd(this, _moduleCache, /* @__PURE__ */ new Map());
    __privateAdd(this, _fakeFileDeps, /* @__PURE__ */ new Map());
    __privateAdd(this, _fakeData, []);
    __publicField(this, "watcher");
    __publicField(this, "watcherDeps");
    this.options = options;
  }
  get fakeData() {
    return __privateGet(this, _fakeData);
  }
  async start() {
    this.watchFakeFileDeps();
    await this.watchFakeFile();
    const { include, exclude, extensions, infixName, root } = this.options;
    const fakeFilePathArr = getFakeFilePath({ exclude, include: [include], extensions, infixName }, root);
    const fakeFilePathFunc = fakeFilePathArr.map((absFile) => () => this.loadFakeData(node_path.relative(root, absFile)));
    await parallelLoader(fakeFilePathFunc, 10);
    this.updateFakeData();
  }
  async watchFakeFile() {
    const { include, watch, root, exclude, loggerOutput, extensions, infixName, logger } = this.options;
    if (include && include.length && watch) {
      let watchPath;
      if (infixName && infixName.length > 0) {
        watchPath = `/**/*.${infixName}.{${extensions.join(",")}}`;
      } else {
        watchPath = `/**/*.{${extensions.join(",")}}`;
      }
      const watchDir = convertPathToPosix(node_path.join(include, watchPath));
      const watcher = chokidar.watch(watchDir, {
        cwd: root,
        ignoreInitial: true,
        ignored: exclude
      });
      this.watcher = watcher;
      watcher.on("add", async (relativeFilePath) => {
        if (logger) {
          loggerOutput.info(colors.green(`fake file add ` + colors.dim(relativeFilePath)), {
            timestamp: true,
            clear: true
          });
        }
        await this.loadFakeData(relativeFilePath);
        this.updateFakeData();
      });
      watcher.on("change", async (relativeFilePath) => {
        if (logger) {
          loggerOutput.info(colors.green(`fake file change ` + colors.dim(relativeFilePath)), {
            timestamp: true,
            clear: true
          });
        }
        await this.loadFakeData(relativeFilePath);
        this.updateFakeData();
      });
      watcher.on("unlink", async (relativeFilePath) => {
        if (logger) {
          loggerOutput.info(colors.green(`fake file unlink ` + colors.dim(relativeFilePath)), {
            timestamp: true,
            clear: true
          });
        }
        __privateGet(this, _moduleCache).delete(relativeFilePath);
        this.updateFakeData();
      });
    }
  }
  watchFakeFileDeps() {
    const { include, watch, root } = this.options;
    if (include && include.length && watch) {
      const watcherDeps = chokidar.watch([], {
        cwd: root,
        ignoreInitial: true
      });
      this.watcherDeps = watcherDeps;
      watcherDeps.on("change", (relativeFilePath) => {
        if (__privateGet(this, _fakeFileDeps).has(relativeFilePath)) {
          const fakeFiles = __privateGet(this, _fakeFileDeps).get(relativeFilePath);
          if (fakeFiles) {
            fakeFiles.forEach(async (filePath) => {
              await this.loadFakeData(filePath);
              this.updateFakeData();
            });
          }
        }
      });
      watcherDeps.on("unlink", async (relativeFilePath) => {
        if (__privateGet(this, _fakeFileDeps).has(relativeFilePath)) {
          __privateGet(this, _fakeFileDeps).delete(relativeFilePath);
        }
      });
      const oldDeps = [];
      this.on("update:deps", () => {
        const deps = [];
        for (const [dep] of __privateGet(this, _fakeFileDeps).entries()) {
          deps.push(dep);
        }
        const exactDeps = deps.filter((dep) => !oldDeps.includes(dep));
        exactDeps.length > 0 && watcherDeps.add(exactDeps);
      });
    }
  }
  async loadFakeData(filepath) {
    const fakeCodeData = [];
    let fakeFileDependencies = {};
    try {
      const { mod, dependencies } = await bundleImport.bundleImport({ filepath, cwd: this.options.root });
      fakeFileDependencies = dependencies;
      const resolvedModule = mod.default || mod;
      if (Array.isArray(resolvedModule)) {
        fakeCodeData.push(...resolvedModule);
      } else {
        fakeCodeData.push(resolvedModule);
      }
    } catch (error) {
      this.options.loggerOutput.error(colors.red(`failed to load module from ${filepath}`), {
        error,
        timestamp: true
      });
    }
    __privateGet(this, _moduleCache).set(filepath, fakeCodeData);
    this.updateFakeFileDeps(filepath, fakeFileDependencies);
    return fakeCodeData;
  }
  updateFakeFileDeps(filepath, deps) {
    Object.keys(deps).forEach((mPath) => {
      const imports = deps[mPath].imports.map((_) => _.path);
      imports.forEach((dep) => {
        if (!__privateGet(this, _fakeFileDeps).has(dep)) {
          __privateGet(this, _fakeFileDeps).set(dep, /* @__PURE__ */ new Set());
        }
        const cur = __privateGet(this, _fakeFileDeps).get(dep);
        cur.add(filepath);
      });
    });
    this.emit("update:deps");
  }
  updateFakeData() {
    let fakeData = [];
    for (const value of __privateGet(this, _moduleCache).values()) {
      fakeData = [...fakeData, ...value];
    }
    __privateSet(this, _fakeData, fakeData);
  }
  close() {
    this.watcher?.close();
    this.watcherDeps?.close();
  }
}
_moduleCache = new WeakMap();
_fakeFileDeps = new WeakMap();
_fakeData = new WeakMap();

/**
 * Sleeps for a specified amount of time.
 * @param {number} time - The time to sleep in milliseconds.
 * @returns {Promise<number>} - A Promise that resolves with the timer ID.
 */
function sleep(time) {
	return new Promise((resolve) => {
		const timer = setTimeout(() => {
			resolve(timer);
			clearTimeout(timer);
		}, time);
	});
}

/**
 * Parses a string into a JSON object.
 * @param {string} str - The string to be parsed.
 * @returns {object} - The parsed to JSON. If parsing fails, a input string is returned.
 */
function tryToJSON(str) {
	let result = "";
	try {
		result = JSON.parse(str);
	} catch (err) {
		result = str;
	}
	return result;
}

async function getResponse({
	URL,
	req,
	fakeModuleList,
	pathToRegexp,
	match,
	basename,
	defaultTimeout,
	globalResponseHeaders,
}) {
	/**
	 * Join two paths into a complete path
	 */
	function joinPathname(a, b) {
		const aPathname = new URL(a, "http://localhost:5173/").pathname;
		const bPathname = new URL(b, "http://localhost:5173/").pathname;
		return aPathname.endsWith("/") ? aPathname.slice(0, -1) + bPathname : aPathname + bPathname;
	}

	if (req.url) {
		const instanceURL = new URL(req.url, "http://localhost:5173/");

		// https://nodejs.org/api/url.html#urlpathname
		// Invalid URL characters included in the value assigned to the pathname property are percent-encoded
		const pathname = instanceURL.pathname;

		const matchRequest = fakeModuleList.find((item) => {
			if (!pathname || !item || !item.url) {
				return false;
			}
			const method = item.method ?? "GET";
			const reqMethod = req.method ?? "GET";
			if (method.toUpperCase() !== reqMethod.toUpperCase()) {
				return false;
			}
			const realURL = joinPathname(basename, item.url);
			return pathToRegexp(realURL).test(pathname);
		});
		if (matchRequest) {
			const {
				response,
				rawResponse,
				timeout = defaultTimeout,
				statusCode,
				statusText,
				url,
				headers: responseHeaders = {},
			} = matchRequest;

			if (timeout) {
				await sleep(timeout);
			}

			const joinedUrl = joinPathname(basename, url);
			const urlMatch = match(joinedUrl, { encode: encodeURI });

			const searchParams = instanceURL.searchParams;
			const query = {};
			for (const [key, value] of searchParams.entries()) {
				if (query.hasOwnProperty(key)) {
					const queryValue = query[key];
					if (Array.isArray(queryValue)) {
						queryValue.push(value);
					} else {
						query[key] = [queryValue, value];
					}
				} else {
					query[key] = value;
				}
			}

			let params = {};

			if (pathname) {
				const matchParams = urlMatch(pathname);
				if (matchParams) {
					params = matchParams.params;
				}
			}

			return {
				response,
				rawResponse,
				timeout,
				statusCode: statusCode ?? 200,
				statusText,
				url: req.url,
				query,
				params,
				responseHeaders: new Headers({ ...globalResponseHeaders, ...responseHeaders }),
			};
		}
	}
}

async function createFakeMiddleware({ loggerOutput, root, ...options }, httpServer) {
  const fakeLoader = new FakeFileLoader({ ...options, loggerOutput, root });
  await fakeLoader.start();
  if (httpServer) {
    httpServer.on("close", () => {
      fakeLoader.close();
    });
  }
  const { basename, timeout: defaultTimeout, headers: globalResponseHeaders, logger } = options;
  const middleware = async (req, res, next) => {
    const responseResult = await getResponse({
      URL: node_url.URL,
      req,
      fakeModuleList: fakeLoader.fakeData,
      pathToRegexp: pathToRegexp.pathToRegexp,
      match: pathToRegexp.match,
      basename,
      defaultTimeout,
      globalResponseHeaders
    });
    if (responseResult) {
      const { rawResponse, response, statusCode, statusText, url, query, params, responseHeaders } = responseResult ?? {};
      if (isFunction(rawResponse)) {
        await Promise.resolve(rawResponse(req, res));
      } else {
        const body = await getRequestData(req);
        for (const key of responseHeaders.keys()) {
          res.setHeader(key, responseHeaders.get(key));
        }
        if (!res.getHeader("Content-Type")) {
          res.setHeader("Content-Type", "application/json");
        }
        res.statusCode = statusCode;
        if (statusText) {
          res.statusMessage = statusText;
        }
        if (isFunction(response)) {
          const fakeResponse = await Promise.resolve(
            response({ url, body: tryToJSON(body), rawBody: body, query, params, headers: req.headers }, req, res)
          );
          if (typeof fakeResponse === "string") {
            res.end(fakeResponse);
          } else {
            res.end(JSON.stringify(fakeResponse, null, 2));
          }
        } else {
          res.end();
        }
      }
      if (logger) {
        loggerOutput.info(colors.green(`request invoke ` + colors.cyan(req.method + " " + req.url)), {
          timestamp: true,
          clear: true
        });
      }
    } else {
      next();
    }
  };
  return middleware;
}

function resolvePluginOptions(options = {}, cwd = process.cwd()) {
  const fakerOptions = resolveOptions({ ...options, include: [options.include || "fake"] });
  for (const filePath of fakerOptions.include) {
    const absolutePath = node_path.join(cwd, filePath);
    if (!node_fs.existsSync(absolutePath)) {
      throw new Error(`${filePath} folder does not exist`);
    }
  }
  return {
    ...fakerOptions,
    include: fakerOptions.include[0],
    enableProd: options.enableProd ?? false,
    enableDev: options.enableDev ?? true,
    watch: options.watch ?? true,
    logger: options.logger ?? true,
    timeout: options.timeout,
    basename: options.basename ?? "",
    headers: options.headers ?? {},
    build: options.build ?? false,
    http2: options.http2
  };
}

/**
 * @namespace xhook
 * @description Easily intercept and modify XHR request and response
 *
 * @copyright Jaime Pillora
 * @see https://github.com/jpillora/xhook
 * @version v1.6.2
 * @license MIT Copyright 2023
 *
 * Fix https://github.com/jpillora/xhook/issues/171
 *
 */

function xhook() {
	//The new code belongs to vite-plugin-fake-server
	const isLink = (linkHref) => {
		try {
			new URL(linkHref);
			return true;
		} catch {
			return false;
		}
	};

	const slice = (o, n) => Array.prototype.slice.call(o, n);

	let result = null;

	//find global object
	if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
		result = self;
	} else if (typeof global !== "undefined") {
		result = global;
	} else if (window) {
		result = window;
	}

	const windowRef = result;
	const documentRef = result.document;

	const UPLOAD_EVENTS = ["load", "loadend", "loadstart"];
	const COMMON_EVENTS = ["progress", "abort", "error", "timeout"];

	const depricatedProp = (p) => ["returnValue", "totalSize", "position"].includes(p);

	const mergeObjects = function (src, dst) {
		for (let k in src) {
			if (depricatedProp(k)) {
				continue;
			}
			const v = src[k];
			try {
				dst[k] = v;
			} catch (error) {}
		}
		return dst;
	};

	//proxy events from one emitter to another
	const proxyEvents = function (events, src, dst) {
		const p = (event) =>
			function (e) {
				const clone = {};
				//copies event, with dst emitter inplace of src
				for (let k in e) {
					if (depricatedProp(k)) {
						continue;
					}
					const val = e[k];
					clone[k] = val === src ? dst : val;
				}
				//emits out the dst
				return dst.dispatchEvent(event, clone);
			};
		//dont proxy manual events
		for (let event of Array.from(events)) {
			if (dst._has(event)) {
				src[`on${event}`] = p(event);
			}
		}
	};

	//create fake event
	const fakeEvent = function (type) {
		if (documentRef && documentRef.createEventObject != null) {
			const msieEventObject = documentRef.createEventObject();
			msieEventObject.type = type;
			return msieEventObject;
		}
		// on some platforms like android 4.1.2 and safari on windows, it appears
		// that new Event is not allowed
		try {
			return new Event(type);
		} catch (error) {
			return { type };
		}
	};

	//tiny event emitter
	const EventEmitter = function (nodeStyle) {
		//private
		let events = {};
		const listeners = (event) => events[event] || [];
		//public
		const emitter = {};
		emitter.addEventListener = function (event, callback, i) {
			events[event] = listeners(event);
			if (events[event].indexOf(callback) >= 0) {
				return;
			}
			i = i === undefined ? events[event].length : i;
			events[event].splice(i, 0, callback);
		};
		emitter.removeEventListener = function (event, callback) {
			//remove all
			if (event === undefined) {
				events = {};
				return;
			}
			//remove all of type event
			if (callback === undefined) {
				events[event] = [];
			}
			//remove particular handler
			const i = listeners(event).indexOf(callback);
			if (i === -1) {
				return;
			}
			listeners(event).splice(i, 1);
		};
		emitter.dispatchEvent = function () {
			const args = slice(arguments);
			const event = args.shift();
			if (!nodeStyle) {
				args[0] = mergeObjects(args[0], fakeEvent(event));
				Object.defineProperty(args[0], "target", {
					writable: false,
					value: this,
				});
			}
			const legacylistener = emitter[`on${event}`];
			if (legacylistener) {
				legacylistener.apply(emitter, args);
			}
			const iterable = listeners(event).concat(listeners("*"));
			for (let i = 0; i < iterable.length; i++) {
				const listener = iterable[i];
				listener.apply(emitter, args);
			}
		};
		emitter._has = (event) => !!(events[event] || emitter[`on${event}`]);
		//add extra aliases
		if (nodeStyle) {
			emitter.listeners = (event) => slice(listeners(event));
			emitter.on = emitter.addEventListener;
			emitter.off = emitter.removeEventListener;
			emitter.fire = emitter.dispatchEvent;
			emitter.once = function (e, fn) {
				var fire = function () {
					emitter.off(e, fire);
					return fn.apply(null, arguments);
				};
				return emitter.on(e, fire);
			};
			emitter.destroy = () => (events = {});
		}

		return emitter;
	};

	//helper
	const CRLF = "\r\n";

	const objectToString = function (headersObj) {
		const entries = Object.entries(headersObj);

		const headers = entries.map(([name, value]) => {
			return `${name.toLowerCase()}: ${value}`;
		});

		return headers.join(CRLF);
	};

	const stringToObject = function (headersString, dest) {
		const headers = headersString.split(CRLF);
		if (dest == null) {
			dest = {};
		}

		for (let header of headers) {
			if (/([^:]+):\s*(.+)/.test(header)) {
				const name = RegExp.$1 != null ? RegExp.$1.toLowerCase() : undefined;
				const value = RegExp.$2;
				if (dest[name] == null) {
					dest[name] = value;
				}
			}
		}

		return dest;
	};

	const convert = function (headers, dest) {
		switch (typeof headers) {
			case "object": {
				return objectToString(headers);
			}
			case "string": {
				return stringToObject(headers, dest);
			}
		}

		return [];
	};

	var headers = { convert };

	//global set of hook functions,
	//uses event emitter to store hooks
	const hooks = EventEmitter(true);

	const nullify = (res) => (res === undefined ? null : res);

	//browser's XMLHttpRequest
	const Native$1 = windowRef.XMLHttpRequest;

	//xhook's XMLHttpRequest
	const Xhook$1 = function () {
		const ABORTED = -1;
		const xhr = new Native$1();

		//==========================
		// Extra state
		const request = {};
		let status = null;
		let hasError = undefined;
		let transiting = undefined;
		let response = undefined;
		var currentState = 0;

		//==========================
		// Private API

		//read results from real xhr into response
		const readHead = function () {
			// Accessing attributes on an aborted xhr object will
			// throw an 'c00c023f error' in IE9 and lower, don't touch it.
			response.status = status || xhr.status;
			if (status !== ABORTED) {
				response.statusText = xhr.statusText;
			}
			if (status !== ABORTED) {
				const object = headers.convert(xhr.getAllResponseHeaders());
				for (let key in object) {
					const val = object[key];
					if (!response.headers[key]) {
						const name = key.toLowerCase();
						response.headers[name] = val;
					}
				}
				return;
			}
		};

		const readBody = function () {
			//https://xhr.spec.whatwg.org/
			if (!xhr.responseType || xhr.responseType === "text") {
				response.text = xhr.responseText;
				response.data = xhr.responseText;
				try {
					response.xml = xhr.responseXML;
				} catch (error) {}
				// unable to set responseXML due to response type, we attempt to assign responseXML
				// when the type is text even though it's against the spec due to several libraries
				// and browser vendors who allow this behavior. causing these requests to fail when
				// xhook is installed on a page.
			} else if (xhr.responseType === "document") {
				response.xml = xhr.responseXML;
				response.data = xhr.responseXML;
			} else {
				response.data = xhr.response;
			}
			//new in some browsers
			if ("responseURL" in xhr) {
				//The new code belongs to vite-plugin-fake-server
				response.responseURL = xhr.responseURL;
			}
		};

		//write response into facade xhr
		const writeHead = function () {
			facade.status = response.status;
			facade.statusText = response.statusText;
		};

		const writeBody = function () {
			if ("text" in response) {
				facade.responseText = response.text;
			}
			if ("xml" in response) {
				facade.responseXML = response.xml;
			}
			if ("data" in response) {
				facade.response = response.data;
			} else {
				//https://github.com/jpillora/xhook/issues/173
				//The new code belongs to vite-plugin-fake-server
				const defaultResponseBody = {
					"": "",
					text: "",
					json: null,
					blob: new Blob([], { type: new Headers(response.headers ?? {}).get("content-type") }),
					arraybuffer: new ArrayBuffer(),
				};
				facade.response = defaultResponseBody[facade.responseType];
			}

			//The new code belongs to vite-plugin-fake-server
			if ("responseURL" in response || request.url) {
				facade.responseURL =
					response.responseURL ?? (isLink(request.url) ? request.url : new URL(location.href).origin + request.url);
			}
		};

		const emitFinal = function () {
			if (!hasError) {
				facade.dispatchEvent("load", {});
			}
			facade.dispatchEvent("loadend", {});
			if (hasError) {
				facade.readyState = 0;
			}
		};

		//ensure ready state 0 through 4 is handled
		const emitReadyState = function (n) {
			while (n > currentState && currentState < 4) {
				facade.readyState = ++currentState;
				// make fake events for libraries that actually check the type on
				// the event object
				if (currentState === 1) {
					facade.dispatchEvent("loadstart", {});
				}
				if (currentState === 2) {
					writeHead();
				}
				if (currentState === 4) {
					writeHead();
					writeBody();
				}
				facade.dispatchEvent("readystatechange", {});
				//delay final events incase of error
				if (currentState === 4) {
					if (request.async === false) {
						emitFinal();
					} else {
						setTimeout(emitFinal, 0);
					}
				}
			}
		};

		//control facade ready state
		const setReadyState = function (n) {
			//emit events until readyState reaches 4
			if (n !== 4) {
				emitReadyState(n);
				return;
			}
			//before emitting 4, run all 'after' hooks in sequence
			const afterHooks = hooks.listeners("after");
			var process = function () {
				if (afterHooks.length > 0) {
					//execute each 'before' hook one at a time
					const hook = afterHooks.shift();
					if (hook.length === 2) {
						hook(request, response);
						process();
					} else if (hook.length === 3 && request.async) {
						hook(request, response, process);
					} else {
						process();
					}
				} else {
					//response ready for reading
					emitReadyState(4);
				}
				return;
			};
			process();
		};

		//==========================
		// Facade XHR
		var facade = EventEmitter();
		request.xhr = facade;

		// Handle the underlying ready state
		xhr.onreadystatechange = function (event) {
			//pull status and headers
			try {
				if (xhr.readyState === 2) {
					readHead();
				}
			} catch (error) {}
			//pull response data
			if (xhr.readyState === 4) {
				transiting = false;
				readHead();
				readBody();
			}

			setReadyState(xhr.readyState);
		};

		//mark this xhr as errored
		const hasErrorHandler = function () {
			hasError = true;
		};
		facade.addEventListener("error", hasErrorHandler);
		facade.addEventListener("timeout", hasErrorHandler);
		facade.addEventListener("abort", hasErrorHandler);
		// progress means we're current downloading...
		facade.addEventListener("progress", function (event) {
			if (currentState < 3) {
				setReadyState(3);
			} else if (xhr.readyState <= 3) {
				//until ready (4), each progress event is followed by readystatechange...
				facade.dispatchEvent("readystatechange", {}); //TODO fake an XHR event
			}
		});

		// initialise 'withCredentials' on facade xhr in browsers with it
		// or if explicitly told to do so
		if ("withCredentials" in xhr) {
			facade.withCredentials = false;
		}
		facade.status = 0;

		// initialise all possible event handlers
		for (let event of Array.from(COMMON_EVENTS.concat(UPLOAD_EVENTS))) {
			facade[`on${event}`] = null;
		}

		facade.open = function (method, url, async, user, pass) {
			// Initailize empty XHR facade
			currentState = 0;
			hasError = false;
			transiting = false;
			//reset request
			request.headers = {};
			request.headerNames = {};
			request.status = 0;
			request.method = method;
			request.url = url;
			request.async = async !== false;
			request.user = user;
			request.pass = pass;
			//reset response
			response = {};
			response.headers = {};
			// openned facade xhr (not real xhr)
			setReadyState(1);
		};

		facade.send = function (body) {
			//read xhr settings before hooking
			let k, modk;
			for (k of ["type", "timeout", "withCredentials"]) {
				modk = k === "type" ? "responseType" : k;
				if (modk in facade) {
					request[k] = facade[modk];
				}
			}

			request.body = body;
			const send = function () {
				//proxy all events from real xhr to facade
				proxyEvents(COMMON_EVENTS, xhr, facade);
				//proxy all upload events from the real to the upload facade
				if (facade.upload) {
					proxyEvents(COMMON_EVENTS.concat(UPLOAD_EVENTS), xhr.upload, facade.upload);
				}

				//prepare request all at once
				transiting = true;
				//perform open
				xhr.open(request.method, request.url, request.async, request.user, request.pass);

				//write xhr settings
				for (k of ["type", "timeout", "withCredentials"]) {
					modk = k === "type" ? "responseType" : k;
					if (k in request) {
						xhr[modk] = request[k];
					}
				}

				//insert headers
				for (let header in request.headers) {
					const value = request.headers[header];
					if (header) {
						xhr.setRequestHeader(header, value);
					}
				}
				//real send!
				xhr.send(request.body);
			};

			const beforeHooks = hooks.listeners("before");
			//process beforeHooks sequentially
			var process = function () {
				if (!beforeHooks.length) {
					return send();
				}
				//go to next hook OR optionally provide response
				const done = function (userResponse) {
					//break chain - provide dummy response (readyState 4)
					if (
						typeof userResponse === "object" &&
						(typeof userResponse.status === "number" || typeof response.status === "number")
					) {
						mergeObjects(userResponse, response);
						if (!("data" in userResponse)) {
							userResponse.data = userResponse.response || userResponse.text;
						}
						setReadyState(4);
						return;
					}
					//continue processing until no beforeHooks left
					process();
				};
				//specifically provide headers (readyState 2)
				done.head = function (userResponse) {
					mergeObjects(userResponse, response);
					setReadyState(2);
				};
				//specifically provide partial text (responseText  readyState 3)
				done.progress = function (userResponse) {
					mergeObjects(userResponse, response);
					setReadyState(3);
				};

				const hook = beforeHooks.shift();
				//async or sync?
				if (hook.length === 1) {
					done(hook(request));
				} else if (hook.length === 2 && request.async) {
					//async handlers must use an async xhr
					hook(request, done);
				} else {
					//skip async hook on sync requests
					done();
				}
				return;
			};
			//kick off
			process();
		};

		facade.abort = function () {
			status = ABORTED;
			if (transiting) {
				xhr.abort(); //this will emit an 'abort' for us
			} else {
				facade.dispatchEvent("abort", {});
			}
		};

		facade.setRequestHeader = function (header, value) {
			//the first header set is used for all future case-alternatives of 'name'
			const lName = header != null ? header.toLowerCase() : undefined;
			const name = (request.headerNames[lName] = request.headerNames[lName] || header);
			//append header to any previous values
			if (request.headers[name]) {
				value = request.headers[name] + ", " + value;
			}
			request.headers[name] = value;
		};
		facade.getResponseHeader = (header) => nullify(response.headers[header ? header.toLowerCase() : undefined]);

		facade.getAllResponseHeaders = () => nullify(headers.convert(response.headers));

		//proxy call only when supported
		if (xhr.overrideMimeType) {
			facade.overrideMimeType = function () {
				xhr.overrideMimeType.apply(xhr, arguments);
			};
		}

		//create emitter when supported
		if (xhr.upload) {
			let up = EventEmitter();
			facade.upload = up;
			request.upload = up;
		}

		facade.UNSENT = 0;
		facade.OPENED = 1;
		facade.HEADERS_RECEIVED = 2;
		facade.LOADING = 3;
		facade.DONE = 4;

		// fill in default values for an empty XHR object according to the spec
		facade.response = "";
		facade.responseText = "";
		facade.responseXML = null;
		facade.readyState = 0;
		facade.statusText = "";

		return facade;
	};

	Xhook$1.UNSENT = 0;
	Xhook$1.OPENED = 1;
	Xhook$1.HEADERS_RECEIVED = 2;
	Xhook$1.LOADING = 3;
	Xhook$1.DONE = 4;

	//patch interface
	var XMLHttpRequest = {
		patch() {
			if (Native$1) {
				windowRef.XMLHttpRequest = Xhook$1;
			}
		},
		unpatch() {
			if (Native$1) {
				windowRef.XMLHttpRequest = Native$1;
			}
		},
		Native: Native$1,
		Xhook: Xhook$1,
	};

	/******************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

	function __rest(s, e) {
		var t = {};
		for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
		if (s != null && typeof Object.getOwnPropertySymbols === "function")
			for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
				if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
			}
		return t;
	}

	function __awaiter(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P
				? value
				: new P(function (resolve) {
						resolve(value);
					});
		}
		return new (P || (P = Promise))(function (resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	}

	//browser's fetch
	const Native = windowRef.fetch;
	function copyToObjFromRequest(req) {
		const copyedKeys = [
			"method",
			"headers",
			"body",
			"mode",
			"credentials",
			"cache",
			"redirect",
			"referrer",
			"referrerPolicy",
			"integrity",
			"keepalive",
			"signal",
			"url",
		];
		let copyedObj = {};
		copyedKeys.forEach((key) => (copyedObj[key] = req[key]));
		return copyedObj;
	}
	function covertHeaderToPlainObj(headers) {
		if (headers instanceof Headers) {
			return covertTDAarryToObj([...headers.entries()]);
		}
		if (Array.isArray(headers)) {
			return covertTDAarryToObj(headers);
		}
		return headers;
	}
	function covertTDAarryToObj(input) {
		return input.reduce((prev, [key, value]) => {
			prev[key] = value;
			return prev;
		}, {});
	}
	/**
	 * if fetch(hacked by Xhook) accept a Request as a first parameter, it will be destrcuted to a plain object.
	 * Finally the whole network request was convert to fectch(Request.url, other options)
	 */
	const Xhook = function (input, init = { headers: {} }) {
		let options = Object.assign(Object.assign({}, init), { isFetch: true });
		if (input instanceof Request) {
			const requestObj = copyToObjFromRequest(input);
			const prevHeaders = Object.assign(
				Object.assign({}, covertHeaderToPlainObj(requestObj.headers)),
				covertHeaderToPlainObj(options.headers),
			);
			options = Object.assign(Object.assign(Object.assign({}, requestObj), init), {
				headers: prevHeaders,
				acceptedRequest: true,
				//The new code belongs to vite-plugin-fake-server
				isFetch: true,
			});
		} else {
			options.url = input;
		}
		const beforeHooks = hooks.listeners("before");
		const afterHooks = hooks.listeners("after");
		return new Promise(function (resolve, reject) {
			let fullfiled = resolve;
			const processAfter = function (response) {
				if (!afterHooks.length) {
					return fullfiled(response);
				}
				const hook = afterHooks.shift();
				if (hook.length === 2) {
					hook(options, response);
					return processAfter(response);
				} else if (hook.length === 3) {
					return hook(options, response, processAfter);
				} else {
					return processAfter(response);
				}
			};
			const done = function (userResponse) {
				if (userResponse !== undefined) {
					const response = new Response(userResponse.body || userResponse.text, userResponse);
					//The new code belongs to vite-plugin-fake-server
					Object.defineProperty(response, "url", {
						value: isLink(options.url) ? options.url : new URL(location.href).origin + options.url,
					});
					resolve(response);
					processAfter(response);
					return;
				}
				//continue processing until no hooks left
				processBefore();
			};
			const processBefore = function () {
				if (!beforeHooks.length) {
					send();
					return;
				}
				const hook = beforeHooks.shift();
				if (hook.length === 1) {
					return done(hook(options));
				} else if (hook.length === 2) {
					return hook(options, done);
				}
			};
			const send = () =>
				__awaiter(this, void 0, void 0, function* () {
					const { url, isFetch, acceptedRequest } = options,
						restInit = __rest(options, ["url", "isFetch", "acceptedRequest"]);
					if (input instanceof Request && restInit.body instanceof ReadableStream) {
						restInit.body = yield new Response(restInit.body).text();
					}
					return Native(url, restInit)
						.then((response) => processAfter(response))
						.catch(function (err) {
							fullfiled = reject;
							processAfter(err);
							return reject(err);
						});
				});
			processBefore();
		});
	};
	//patch interface
	var fetch = {
		patch() {
			if (Native) {
				windowRef.fetch = Xhook;
			}
		},
		unpatch() {
			if (Native) {
				windowRef.fetch = Native;
			}
		},
		Native,
		Xhook,
	};

	//the global hooks event emitter is also the global xhook object
	//(not the best decision in hindsight)
	const xhook = hooks;
	xhook.EventEmitter = EventEmitter;
	//modify hooks
	xhook.before = function (handler, i) {
		if (handler.length < 1 || handler.length > 2) {
			throw "invalid hook";
		}
		return xhook.on("before", handler, i);
	};
	xhook.after = function (handler, i) {
		if (handler.length < 2 || handler.length > 3) {
			throw "invalid hook";
		}
		return xhook.on("after", handler, i);
	};

	//globally enable/disable
	xhook.enable = function () {
		XMLHttpRequest.patch();
		fetch.patch();
	};
	xhook.disable = function () {
		XMLHttpRequest.unpatch();
		fetch.unpatch();
	};
	//expose native objects
	xhook.XMLHttpRequest = XMLHttpRequest.Native;
	xhook.fetch = fetch.Native;

	//expose helpers
	xhook.headers = headers.convert;

	//enable by default
	xhook.enable();

	return xhook;
}

const require$1 = node_module.createRequire((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.src || new URL('index.cjs', document.baseURI).href)));
const vitePluginFakeServer = async (options = {}) => {
  let config;
  let isDevServer = false;
  let opts;
  return {
    name: "vite-plugin-fake-server",
    config: (unresolvedConfig) => {
      const currentWorkingDirectory = process.cwd();
      const root = unresolvedConfig.root ?? currentWorkingDirectory;
      const absoluteRoot = node_path.isAbsolute(root) ? root : node_path.join(currentWorkingDirectory, root);
      opts = resolvePluginOptions({ ...options, http2: options.http2 ?? !!unresolvedConfig.server }, absoluteRoot);
      return {
        server: {
          watch: {
            ignored: resolveIgnored(absoluteRoot, opts.include, unresolvedConfig?.server?.watch)
          }
        }
      };
    },
    configResolved(resolvedConfig) {
      config = resolvedConfig;
      if (resolvedConfig.command === "serve") {
        isDevServer = true;
      }
    },
    async configureServer({ middlewares, httpServer }) {
      if (isDevServer && opts.enableDev) {
        const loggerOutput = createLogger(config.logLevel, {
          allowClearScreen: config.clearScreen,
          customLogger: config.customLogger
        });
        const middleware = await createFakeMiddleware({ ...opts, loggerOutput, root: config.root }, httpServer);
        middlewares.use(middleware);
      }
    },
    transformIndexHtml: {
      order: "pre",
      handler: async (htmlString) => {
        if (isDevServer || !opts.enableProd) {
          return htmlString;
        }
        const scriptTagOptions = {
          tag: "script",
          attrs: { type: "module" },
          injectTo: "head"
        };
        const scriptTagList = [];
        if (opts.logger) {
          scriptTagList.push({
            ...scriptTagOptions,
            children: [
              `console.warn("[`,
              pkg.name,
              "]:",
              "The plugin is applied in the production environment, check in https://github.com/condorheroblog/vite-plugin-fake-server#enableprod",
              `");`
            ].join("")
          });
        }
        scriptTagList.push({
          ...scriptTagOptions,
          children: [
            "window.__VITE__PLUGIN__FAKE__SERVER__",
            "=",
            JSON.stringify({ meta: pkg, vitePluginFakeServerOptions: opts }, null, 2),
            ";"
          ].join("")
        });
        const fakeFilePath = getFakeFilePath(
          {
            include: opts.include.length ? [opts.include] : [],
            exclude: opts.exclude,
            extensions: opts.extensions,
            infixName: opts.infixName
          },
          config.root
        );
        const relativeFakeFilePath = fakeFilePath.map(
          (filePath) => convertPathToPosix("/" + node_path.relative(config.root, filePath))
        );
        const fakeTemplate = `
					const modules = import.meta.glob(${JSON.stringify(relativeFakeFilePath, null, 2)}, { eager: true });
					const fakeModuleList = Object.keys(modules).reduce((list, key) => {
						const module = modules[key] ?? {};
						if (module.default) {
							for (const moduleKey of Object.keys(module)) {
								const mod = modules[key][moduleKey] ?? [];
								const modList = Array.isArray(mod) ? [...mod] : [mod];
								return [...list, ...modList];
							}
						} else {
							return list;
						}
					}, []);
					window.__VITE__PLUGIN__FAKE__SERVER__.fakeModuleList = fakeModuleList;
				`;
        scriptTagList.push({
          ...scriptTagOptions,
          children: fakeTemplate
        });
        scriptTagList.push({
          ...scriptTagOptions,
          children: `${xhook.toString()};window.__VITE__PLUGIN__FAKE__SERVER__.xhook=xhook();`
        });
        const pathToRegexpPath = node_path.join(node_path.dirname(require$1.resolve("path-to-regexp")), "../dist.es2015/index.js");
        const pathToRegexpContent = node_fs.readFileSync(pathToRegexpPath, "utf-8");
        scriptTagList.push({
          ...scriptTagOptions,
          children: `${pathToRegexpContent}
;window.__VITE__PLUGIN__FAKE__SERVER__.pathToRegexp={pathToRegexp, match};`
        });
        scriptTagList.push({
          ...scriptTagOptions,
          children: `const fakeModuleList = window.__VITE__PLUGIN__FAKE__SERVER__.fakeModuleList;
					const { pathToRegexp, match } = window.__VITE__PLUGIN__FAKE__SERVER__.pathToRegexp;
					window.__VITE__PLUGIN__FAKE__SERVER__.xhook.before(async function(req, callback) {
						${sleep.toString()}
						${tryToJSON.toString()}
						${getResponse.toString()}
						const STATUS_CODES = ${JSON.stringify(node_http.STATUS_CODES, null, 2)};

						function headersToObject(headers) {
							const headersObject = {};
							for (const [name, value] of headers.entries()) {
								headersObject[name] = value;
							}
							return headersObject;
						}

						const responseResult = await getResponse({
							URL,
							req,
							fakeModuleList,
							pathToRegexp,
							match,
							basename: ${JSON.stringify(opts.basename)},
							defaultTimeout: ${JSON.stringify(opts.timeout)},
							globalResponseHeaders: ${JSON.stringify(opts.headers, null, 2)}
						});
						if (responseResult) {
							const {
								response,
								statusCode,
								statusText: responseStatusText = STATUS_CODES[statusCode],
								url,
								query,
								params,
								responseHeaders,
							} = responseResult ?? {};
							const statusText = ${JSON.stringify(opts.http2)} ? "" : responseStatusText;
							const responseIsFunction = typeof response === "function";
							const requestHeaders = {};
							for (const key in req.headers) {
								requestHeaders[key.toLowerCase()] = req.headers[key];
							}
							const fakeResponse = !responseIsFunction || await Promise.resolve(
								response({ url, body: tryToJSON(req.body), rawBody: req.body, query, params, headers: requestHeaders })
							);
							if(req.isFetch) {
								if (typeof fakeResponse === "string") {
									if (!responseHeaders.get("Content-Type")) {
										responseHeaders.set("Content-Type", "text/plain");
									}
									callback(new Response(
										responseIsFunction ? fakeResponse : null,
										{
											statusText,
											status: statusCode,
											headers: headersToObject(responseHeaders),
										}
									));
								} else {
									if (!responseHeaders.get("Content-Type")) {
										responseHeaders.set("Content-Type", "application/json");
									}
									callback(new Response(
										responseIsFunction ? JSON.stringify(fakeResponse, null, 2) : null,
										{
											statusText,
											status: statusCode,
											headers: headersToObject(responseHeaders),
										}
									));
								}
							} else {
								const dataResponse = responseIsFunction ? { data: fakeResponse } : {};
								if(!req.type || req.type.toLowerCase() === "text") {
									if (!responseHeaders.get("Content-Type")) {
										responseHeaders.set("Content-Type", "text/plain");
									}
									callback({
										statusText,
										status: statusCode,
										text: fakeResponse,
										...dataResponse,
										headers: headersToObject(responseHeaders),
									});
								} else if (req.type.toLowerCase() === "json") {
									if (!responseHeaders.get("Content-Type")) {
										responseHeaders.set("Content-Type", "application/json");
									}
									callback({
										statusText,
										status: statusCode,
										...dataResponse,
										headers: headersToObject(responseHeaders),
									});
								} else if (req.type.toLowerCase() === "document") {
									if (!responseHeaders.get("Content-Type")) {
										responseHeaders.set("Content-Type", "application/xml");
									}
									const parser = new DOMParser();
									const xmlDoc = parser.parseFromString(fakeResponse,"application/xml");
									callback({
										statusText,
										status: statusCode,
										xml: xmlDoc,
										data: xmlDoc,
										headers: headersToObject(responseHeaders),
									});
								} else {
									// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType
									// "arraybuffer" | "blob"
									callback({
										statusText,
										status: statusCode,
										...dataResponse,
										headers: headersToObject(responseHeaders),
									});
								}
							}
							if (${JSON.stringify(opts.logger)}){
								const requestMethod = req.method ? req.method.toUpperCase() : "GET";
								console.log("%c request invoke" + " %c" + requestMethod + " " + req.url, "color: green", "color: blue");
							}
						} else {
							// next external URL
							callback();
						}
					});`
        });
        return scriptTagList;
      }
    },
    async closeBundle() {
      if (!isDevServer && opts.build) {
        await generateFakeServer(opts, config);
      }
    }
  };
};
function resolveIgnored(rootDir, include, watchOptions) {
  const { ignored = [] } = watchOptions ?? {};
  return [convertPathToPosix(node_path.join(rootDir, include, "**")), ...Array.isArray(ignored) ? ignored : [ignored]];
}

function defineFakeRoute(config) {
  return config;
}

exports.FAKE_FILE_EXTENSIONS = FAKE_FILE_EXTENSIONS;
exports.FakeFileLoader = FakeFileLoader;
exports.INFIX_NAME = INFIX_NAME;
exports.LogLevels = LogLevels;
exports.OUTPUT_DIR = OUTPUT_DIR;
exports.PORT = PORT;
exports.convertPathToPosix = convertPathToPosix;
exports.copyFakeFiles = copyFakeFiles;
exports.createFakeMiddleware = createFakeMiddleware;
exports.createLogger = createLogger;
exports.defineFakeRoute = defineFakeRoute;
exports.generateFakeServer = generateFakeServer;
exports.getFakeFilePath = getFakeFilePath;
exports.getRequestData = getRequestData;
exports.getResponse = getResponse;
exports.isFunction = isFunction;
exports.parallelLoader = parallelLoader;
exports.resolveIgnored = resolveIgnored;
exports.resolveOptions = resolveOptions;
exports.resolvePluginOptions = resolvePluginOptions;
exports.sleep = sleep;
exports.tryToJSON = tryToJSON;
exports.version = version;
exports.vitePluginFakeServer = vitePluginFakeServer;
